# -*- coding: utf-8 -*-
"""21BCE111_IRS_Practical_8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-ymPxLfvlyVm2dTrfefj0-9u_bChd5th
"""

import numpy as np
from sklearn.metrics import mean_squared_error

class RecommendationSystem:
    def __init__(self, utility_matrix):
        self.utility_matrix = utility_matrix
        self.num_users, self.num_items = utility_matrix.shape

    def centered_cosine_similarity(self, x, y):
        # Calculate centered cosine similarity between vectors x and y
        x_mean = np.mean(x[np.where(x != 0)])
        y_mean = np.mean(y[np.where(y != 0)])
        if np.isnan(x_mean) or np.isnan(y_mean):
            return 0
        num = np.sum((x - x_mean) * (y - y_mean))
        den = np.sqrt(np.sum((x - x_mean)**2) * np.sum((y - y_mean)**2))
        if den == 0:
            return 0
        return num / den

    def user_user_collaborative_filtering(self, user_id, k=5):
        similarities = np.zeros(self.num_users)
        for i in range(self.num_users):
            similarities[i] = self.centered_cosine_similarity(self.utility_matrix[user_id], self.utility_matrix[i])
        ranked_users = np.argsort(similarities)[::-1]  # Sort in descending order
        rated_items = np.where(self.utility_matrix[user_id] != 0)[0]
        recommendations = []
        for item_id in range(self.num_items):
            if item_id not in rated_items:
                weighted_sum = 0
                sum_of_similarities = 0
                for j in range(k):
                    similar_user_id = ranked_users[j]
                    if self.utility_matrix[similar_user_id, item_id] != 0:
                        weighted_sum += similarities[similar_user_id] * self.utility_matrix[similar_user_id, item_id]
                        sum_of_similarities += np.abs(similarities[similar_user_id])
                if sum_of_similarities != 0:
                    recommendations.append((item_id, weighted_sum / sum_of_similarities))
        recommendations.sort(key=lambda x: x[1], reverse=True)
        return recommendations

    def item_item_collaborative_filtering(self, user_id, k=5):
        similarities = np.zeros(self.num_items)
        for i in range(self.num_items):
            similarities[i] = self.centered_cosine_similarity(self.utility_matrix[:, user_id], self.utility_matrix[:, i])
        ranked_items = np.argsort(similarities)[::-1]  # Sort in descending order
        rated_items = np.where(self.utility_matrix[:, user_id] != 0)[0]
        recommendations = []
        for item_id in range(self.num_items):
            if item_id not in rated_items:
                weighted_sum = 0
                sum_of_similarities = 0
                for j in range(k):
                    similar_item_id = ranked_items[j]
                    if self.utility_matrix[similar_item_id, user_id] != 0:
                        weighted_sum += similarities[similar_item_id] * self.utility_matrix[similar_item_id, user_id]
                        sum_of_similarities += np.abs(similarities[similar_item_id])
                if sum_of_similarities != 0:
                    recommendations.append((item_id, weighted_sum / sum_of_similarities))
        recommendations.sort(key=lambda x: x[1], reverse=True)
        return recommendations

def split_data(utility_matrix, test_ratio=0.2):
    num_users, num_items = utility_matrix.shape
    test_indices = np.random.choice(range(num_users * num_items), size=int(test_ratio * num_users * num_items), replace=False)
    test_mask = np.zeros((num_users, num_items))
    test_mask[np.unravel_index(test_indices, (num_users, num_items))] = 1
    train_mask = 1 - test_mask
    train_data = utility_matrix * train_mask
    test_data = utility_matrix * test_mask
    return train_data, test_data

# Example usage:
if __name__ == "__main__":
    # Sample utility matrix (randomly initialized)
    utility_matrix = np.random.randint(1, 6, size=(10, 10)) * np.random.choice([0, 1], size=(10, 10))

    # Split the data into training and testing sets
    train_data, test_data = split_data(utility_matrix)

    # Create recommendation system
    rs = RecommendationSystem(train_data)

    # Get recommendations for user 0 using user-user collaborative filtering
    user_user_recommendations = rs.user_user_collaborative_filtering(0)
    print("User-User Collaborative Filtering Recommendations for User 0:")
    print(user_user_recommendations)

    # Get recommendations for user 0 using item-item collaborative filtering
    item_item_recommendations = rs.item_item_collaborative_filtering(0)
    print("Item-Item Collaborative Filtering Recommendations for User 0:")
    print(item_item_recommendations)

    # Evaluate using RMSE
    predicted_ratings_user_user = np.zeros_like(test_data)
    predicted_ratings_item_item = np.zeros_like(test_data)

    for user_id in range(test_data.shape[0]):
        user_user_recommendations = rs.user_user_collaborative_filtering(user_id)
        item_item_recommendations = rs.item_item_collaborative_filtering(user_id)
        for item_id, rating in user_user_recommendations:
            predicted_ratings_user_user[user_id, item_id] = rating
        for item_id, rating in item_item_recommendations:
            predicted_ratings_item_item[user_id, item_id] = rating

    # Flatten the arrays for computing RMSE
    true_ratings = test_data[test_data != 0]
    predicted_ratings_user_user = predicted_ratings_user_user[test_data != 0]
    predicted_ratings_item_item = predicted_ratings_item_item[test_data != 0]

    rmse_user_user = np.sqrt(mean_squared_error(true_ratings, predicted_ratings_user_user))
    rmse_item_item = np.sqrt(mean_squared_error(true_ratings, predicted_ratings_item_item))

    print(f"RMSE for User-User Collaborative Filtering: {rmse_user_user}")
    print(f"RMSE for Item-Item Collaborative Filtering: {rmse_item_item}")